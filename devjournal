---------------------------------------
2021/09/30 takeshi:

Draft

We will use an actor library and will process events from 3 sources this way:

SIP stack:
  server-side:
    - INVITE: 
      - parse and validate SDP (if not valid, refuse the request at this point)
      - notify sip_new_session
    - BYE:
      - notify sip_session_terminated
      
  client-side:
    - INVITE Response:
      - notify sip_invite_response
    - BYE: 
      - notify sip_session_terminated

MRCP socket:
  - error: notify_mrcp_error
  - close: notify mrcp_closed
  - data: notify mrcp_msg

RTP session:
  - error: notify rtp_error
  - closed: notify rtp_closed
  - data: notify rtp_data


The events above will be notified to the session actor that will handle the events this way:

session_actor:
  - mrcp_closed:
    - notify end of session.
    - start timer to end the other entities
  - mrcp_error:  
    - notify end of session.
    - start timer to end the other entities
  - sip_session_terminated: 
    - notify end of session
    - start timer to end the other entities
  - sip_new_session:
    - call new_session_callback (callback should accept or refuse the call)
  - sip_invite_response:
    - 200 OK:
      - parse SDP and confirm it is OK (if not call create_session_callback(error))
      - create mrcp_session and wait for 'connected' or 'error' (if fail, call create_session_callback(error))
      - call create_session_callback(OK)
    - XXX SIP ERROR:
      - call create_session_callback(error)
  - mrcp_msg: 
    - notify on('mrcp_msg') subscribers
  - rtp_error:
    - start timer to end the other entities
  - rtp_closed:
    - start timer to end the other entities
  - rtp_data:
    - notify on('rtp_data') subscribers 

